{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.20;\n\nimport {IAccessControl} from \"@openzeppelin/contracts/access/IAccessControl.sol\";\nimport {ContextUpgradeable} from \"../utils/ContextUpgradeable.sol\";\nimport {ERC165Upgradeable} from \"../utils/introspection/ERC165Upgradeable.sol\";\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControlUpgradeable is Initializable, ContextUpgradeable, IAccessControl, ERC165Upgradeable {\n    struct RoleData {\n        mapping(address account => bool) hasRole;\n        bytes32 adminRole;\n    }\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.AccessControl\n    struct AccessControlStorage {\n        mapping(bytes32 role => RoleData) _roles;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.AccessControl\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant AccessControlStorageLocation = 0x02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b626800;\n\n    function _getAccessControlStorage() private pure returns (AccessControlStorage storage $) {\n        assembly {\n            $.slot := AccessControlStorageLocation\n        }\n    }\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    function __AccessControl_init() internal onlyInitializing {\n    }\n\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].hasRole[account];\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\n     * is missing `role`.\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n\n        _revokeRole(role, callerConfirmation);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        $._roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (!hasRole(role, account)) {\n            $._roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (hasRole(role, account)) {\n            $._roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Storage of the initializable contract.\n     *\n     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n     * when using with upgradeable contracts.\n     *\n     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n     */\n    struct InitializableStorage {\n        /**\n         * @dev Indicates that the contract has been initialized.\n         */\n        uint64 _initialized;\n        /**\n         * @dev Indicates that the contract is in the process of being initialized.\n         */\n        bool _initializing;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Initializable\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n\n    /**\n     * @dev The contract is already initialized.\n     */\n    error InvalidInitialization();\n\n    /**\n     * @dev The contract is not initializing.\n     */\n    error NotInitializing();\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint64 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n     * production.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        // Cache values to avoid duplicated sloads\n        bool isTopLevelCall = !$._initializing;\n        uint64 initialized = $._initialized;\n\n        // Allowed calls:\n        // - initialSetup: the contract is not in the initializing state and no previous version was\n        //                 initialized\n        // - construction: the contract is initialized at version 1 (no reininitialization) and the\n        //                 current contract is just being deployed\n        bool initialSetup = initialized == 0 && isTopLevelCall;\n        bool construction = initialized == 1 && address(this).code.length == 0;\n\n        if (!initialSetup && !construction) {\n            revert InvalidInitialization();\n        }\n        $._initialized = 1;\n        if (isTopLevelCall) {\n            $._initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            $._initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint64 version) {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing || $._initialized >= version) {\n            revert InvalidInitialization();\n        }\n        $._initialized = version;\n        $._initializing = true;\n        _;\n        $._initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        _checkInitializing();\n        _;\n    }\n\n    /**\n     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n     */\n    function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }\n\n    /**\n     * @dev Returns a pointer to the storage namespace.\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        assembly {\n            $.slot := INITIALIZABLE_STORAGE\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/utils/UUPSUpgradeable.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC1822Proxiable} from \"@openzeppelin/contracts/interfaces/draft-IERC1822.sol\";\nimport {ERC1967Utils} from \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Utils.sol\";\nimport {Initializable} from \"./Initializable.sol\";\n\n/**\n * @dev An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade of an\n * {ERC1967Proxy}, when this contract is set as the implementation behind such a proxy.\n *\n * A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is\n * reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing\n * `UUPSUpgradeable` with a custom implementation of upgrades.\n *\n * The {_authorizeUpgrade} function must be overridden to include access restriction to the upgrade mechanism.\n */\nabstract contract UUPSUpgradeable is Initializable, IERC1822Proxiable {\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    address private immutable __self = address(this);\n\n    /**\n     * @dev The version of the upgrade interface of the contract. If this getter is missing, both `upgradeTo(address)`\n     * and `upgradeToAndCall(address,bytes)` are present, and `upgradeTo` must be used if no function should be called,\n     * while `upgradeToAndCall` will invoke the `receive` function if the second argument is the empty byte string.\n     * If the getter returns `\"5.0.0\"`, only `upgradeToAndCall(address,bytes)` is present, and the second argument must\n     * be the empty byte string if no function should be called, making it impossible to invoke the `receive` function\n     * during an upgrade.\n     */\n    string public constant UPGRADE_INTERFACE_VERSION = \"5.0.0\";\n\n    /**\n     * @dev The call is from an unauthorized context.\n     */\n    error UUPSUnauthorizedCallContext();\n\n    /**\n     * @dev The storage `slot` is unsupported as a UUID.\n     */\n    error UUPSUnsupportedProxiableUUID(bytes32 slot);\n\n    /**\n     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\n     * a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case\n     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\n     * function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\n     * fail.\n     */\n    modifier onlyProxy() {\n        _checkProxy();\n        _;\n    }\n\n    /**\n     * @dev Check that the execution is not being performed through a delegate call. This allows a function to be\n     * callable on the implementing contract but not through proxies.\n     */\n    modifier notDelegated() {\n        _checkNotDelegated();\n        _;\n    }\n\n    function __UUPSUpgradeable_init() internal onlyInitializing {\n    }\n\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the\n     * implementation. It is used to validate the implementation's compatibility when performing an upgrade.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.\n     */\n    function proxiableUUID() external view virtual notDelegated returns (bytes32) {\n        return ERC1967Utils.IMPLEMENTATION_SLOT;\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\n     * encoded in `data`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     *\n     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data);\n    }\n\n    /**\n     * @dev Reverts if the execution is not performed via delegatecall or the execution\n     * context is not of a proxy with an ERC1967-compliant implementation pointing to self.\n     * See {_onlyProxy}.\n     */\n    function _checkProxy() internal view virtual {\n        if (\n            address(this) == __self || // Must be called through delegatecall\n            ERC1967Utils.getImplementation() != __self // Must be called through an active proxy\n        ) {\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n\n    /**\n     * @dev Reverts if the execution is performed via delegatecall.\n     * See {notDelegated}.\n     */\n    function _checkNotDelegated() internal view virtual {\n        if (address(this) != __self) {\n            // Must not be called through delegatecall\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n\n    /**\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\n     * {upgradeToAndCall}.\n     *\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\n     *\n     * ```solidity\n     * function _authorizeUpgrade(address) internal onlyOwner {}\n     * ```\n     */\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n\n    /**\n     * @dev Performs an implementation upgrade with a security check for UUPS proxies, and additional setup call.\n     *\n     * As a security check, {proxiableUUID} is invoked in the new implementation, and the return value\n     * is expected to be the implementation slot in ERC1967.\n     *\n     * Emits an {IERC1967-Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data) private {\n        try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n            if (slot != ERC1967Utils.IMPLEMENTATION_SLOT) {\n                revert UUPSUnsupportedProxiableUUID(slot);\n            }\n            ERC1967Utils.upgradeToAndCall(newImplementation, data);\n        } catch {\n            // The implementation is not UUPS\n            revert ERC1967Utils.ERC1967InvalidImplementation(newImplementation);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {Initializable} from \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165Upgradeable is Initializable, IERC165 {\n    function __ERC165_init() internal onlyInitializing {\n    }\n\n    function __ERC165_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Pausable.sol)\n\npragma solidity ^0.8.20;\n\nimport {ContextUpgradeable} from \"../utils/ContextUpgradeable.sol\";\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\n    /// @custom:storage-location erc7201:openzeppelin.storage.Pausable\n    struct PausableStorage {\n        bool _paused;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Pausable\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant PausableStorageLocation = 0xcd5ed15c6e187e77e9aee88184c21f4f2182ab5827cb3b7e07fbedcd63f03300;\n\n    function _getPausableStorage() private pure returns (PausableStorage storage $) {\n        assembly {\n            $.slot := PausableStorageLocation\n        }\n    }\n\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    /**\n     * @dev The operation failed because the contract is paused.\n     */\n    error EnforcedPause();\n\n    /**\n     * @dev The operation failed because the contract is not paused.\n     */\n    error ExpectedPause();\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    function __Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n\n    function __Pausable_init_unchained() internal onlyInitializing {\n        PausableStorage storage $ = _getPausableStorage();\n        $._paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        PausableStorage storage $ = _getPausableStorage();\n        return $._paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        if (paused()) {\n            revert EnforcedPause();\n        }\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        if (!paused()) {\n            revert ExpectedPause();\n        }\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        PausableStorage storage $ = _getPausableStorage();\n        $._paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        PausableStorage storage $ = _getPausableStorage();\n        $._paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.ReentrancyGuard\n    struct ReentrancyGuardStorage {\n        uint256 _status;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.ReentrancyGuard\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant ReentrancyGuardStorageLocation = 0x9b779b17422d0df92223018b32b4d1fa46e071723d6817e2486d003becc55f00;\n\n    function _getReentrancyGuardStorage() private pure returns (ReentrancyGuardStorage storage $) {\n        assembly {\n            $.slot := ReentrancyGuardStorageLocation\n        }\n    }\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        $._status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if ($._status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        $._status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        $._status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        return $._status == ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/IAccessControl.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev The `account` is missing a role.\n     */\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n\n    /**\n     * @dev The caller of a function is not the expected one.\n     *\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\n     */\n    error AccessControlBadConfirmation();\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}\n"
    },
    "@openzeppelin/contracts/interfaces/draft-IERC1822.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/draft-IERC1822.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\n * proxy whose upgrades are fully controlled by the current implementation.\n */\ninterface IERC1822Proxiable {\n    /**\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\n     * address.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy.\n     */\n    function proxiableUUID() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC4626.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC4626.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../token/ERC20/IERC20.sol\";\nimport {IERC20Metadata} from \"../token/ERC20/extensions/IERC20Metadata.sol\";\n\n/**\n * @dev Interface of the ERC4626 \"Tokenized Vault Standard\", as defined in\n * https://eips.ethereum.org/EIPS/eip-4626[ERC-4626].\n */\ninterface IERC4626 is IERC20, IERC20Metadata {\n    event Deposit(address indexed sender, address indexed owner, uint256 assets, uint256 shares);\n\n    event Withdraw(\n        address indexed sender,\n        address indexed receiver,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /**\n     * @dev Returns the address of the underlying token used for the Vault for accounting, depositing, and withdrawing.\n     *\n     * - MUST be an ERC-20 token contract.\n     * - MUST NOT revert.\n     */\n    function asset() external view returns (address assetTokenAddress);\n\n    /**\n     * @dev Returns the total amount of the underlying asset that is “managed” by Vault.\n     *\n     * - SHOULD include any compounding that occurs from yield.\n     * - MUST be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT revert.\n     */\n    function totalAssets() external view returns (uint256 totalManagedAssets);\n\n    /**\n     * @dev Returns the amount of shares that the Vault would exchange for the amount of assets provided, in an ideal\n     * scenario where all the conditions are met.\n     *\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT show any variations depending on the caller.\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\n     * - MUST NOT revert.\n     *\n     * NOTE: This calculation MAY NOT reflect the “per-user” price-per-share, and instead should reflect the\n     * “average-user’s” price-per-share, meaning what the average user should expect to see when exchanging to and\n     * from.\n     */\n    function convertToShares(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Returns the amount of assets that the Vault would exchange for the amount of shares provided, in an ideal\n     * scenario where all the conditions are met.\n     *\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT show any variations depending on the caller.\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\n     * - MUST NOT revert.\n     *\n     * NOTE: This calculation MAY NOT reflect the “per-user” price-per-share, and instead should reflect the\n     * “average-user’s” price-per-share, meaning what the average user should expect to see when exchanging to and\n     * from.\n     */\n    function convertToAssets(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Returns the maximum amount of the underlying asset that can be deposited into the Vault for the receiver,\n     * through a deposit call.\n     *\n     * - MUST return a limited value if receiver is subject to some deposit limit.\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of assets that may be deposited.\n     * - MUST NOT revert.\n     */\n    function maxDeposit(address receiver) external view returns (uint256 maxAssets);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their deposit at the current block, given\n     * current on-chain conditions.\n     *\n     * - MUST return as close to and no more than the exact amount of Vault shares that would be minted in a deposit\n     *   call in the same transaction. I.e. deposit should return the same or more shares as previewDeposit if called\n     *   in the same transaction.\n     * - MUST NOT account for deposit limits like those returned from maxDeposit and should always act as though the\n     *   deposit would be accepted, regardless if the user has enough tokens approved, etc.\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToShares and previewDeposit SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\n     */\n    function previewDeposit(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Mints shares Vault shares to receiver by depositing exactly amount of underlying tokens.\n     *\n     * - MUST emit the Deposit event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   deposit execution, and are accounted for during deposit.\n     * - MUST revert if all of assets cannot be deposited (due to deposit limit being reached, slippage, the user not\n     *   approving enough underlying tokens to the Vault contract, etc).\n     *\n     * NOTE: most implementations will require pre-approval of the Vault with the Vault’s underlying asset token.\n     */\n    function deposit(uint256 assets, address receiver) external returns (uint256 shares);\n\n    /**\n     * @dev Returns the maximum amount of the Vault shares that can be minted for the receiver, through a mint call.\n     * - MUST return a limited value if receiver is subject to some mint limit.\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of shares that may be minted.\n     * - MUST NOT revert.\n     */\n    function maxMint(address receiver) external view returns (uint256 maxShares);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their mint at the current block, given\n     * current on-chain conditions.\n     *\n     * - MUST return as close to and no fewer than the exact amount of assets that would be deposited in a mint call\n     *   in the same transaction. I.e. mint should return the same or fewer assets as previewMint if called in the\n     *   same transaction.\n     * - MUST NOT account for mint limits like those returned from maxMint and should always act as though the mint\n     *   would be accepted, regardless if the user has enough tokens approved, etc.\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewMint SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by minting.\n     */\n    function previewMint(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Mints exactly shares Vault shares to receiver by depositing amount of underlying tokens.\n     *\n     * - MUST emit the Deposit event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the mint\n     *   execution, and are accounted for during mint.\n     * - MUST revert if all of shares cannot be minted (due to deposit limit being reached, slippage, the user not\n     *   approving enough underlying tokens to the Vault contract, etc).\n     *\n     * NOTE: most implementations will require pre-approval of the Vault with the Vault’s underlying asset token.\n     */\n    function mint(uint256 shares, address receiver) external returns (uint256 assets);\n\n    /**\n     * @dev Returns the maximum amount of the underlying asset that can be withdrawn from the owner balance in the\n     * Vault, through a withdraw call.\n     *\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\n     * - MUST NOT revert.\n     */\n    function maxWithdraw(address owner) external view returns (uint256 maxAssets);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their withdrawal at the current block,\n     * given current on-chain conditions.\n     *\n     * - MUST return as close to and no fewer than the exact amount of Vault shares that would be burned in a withdraw\n     *   call in the same transaction. I.e. withdraw should return the same or fewer shares as previewWithdraw if\n     *   called\n     *   in the same transaction.\n     * - MUST NOT account for withdrawal limits like those returned from maxWithdraw and should always act as though\n     *   the withdrawal would be accepted, regardless if the user has enough shares, etc.\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToShares and previewWithdraw SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\n     */\n    function previewWithdraw(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Burns shares from owner and sends exactly assets of underlying tokens to receiver.\n     *\n     * - MUST emit the Withdraw event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   withdraw execution, and are accounted for during withdraw.\n     * - MUST revert if all of assets cannot be withdrawn (due to withdrawal limit being reached, slippage, the owner\n     *   not having enough shares, etc).\n     *\n     * Note that some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\n     * Those methods should be performed separately.\n     */\n    function withdraw(uint256 assets, address receiver, address owner) external returns (uint256 shares);\n\n    /**\n     * @dev Returns the maximum amount of Vault shares that can be redeemed from the owner balance in the Vault,\n     * through a redeem call.\n     *\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\n     * - MUST return balanceOf(owner) if owner is not subject to any withdrawal limit or timelock.\n     * - MUST NOT revert.\n     */\n    function maxRedeem(address owner) external view returns (uint256 maxShares);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their redeemption at the current block,\n     * given current on-chain conditions.\n     *\n     * - MUST return as close to and no more than the exact amount of assets that would be withdrawn in a redeem call\n     *   in the same transaction. I.e. redeem should return the same or more assets as previewRedeem if called in the\n     *   same transaction.\n     * - MUST NOT account for redemption limits like those returned from maxRedeem and should always act as though the\n     *   redemption would be accepted, regardless if the user has enough shares, etc.\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewRedeem SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by redeeming.\n     */\n    function previewRedeem(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Burns exactly shares from owner and sends assets of underlying tokens to receiver.\n     *\n     * - MUST emit the Withdraw event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   redeem execution, and are accounted for during redeem.\n     * - MUST revert if all of shares cannot be redeemed (due to withdrawal limit being reached, slippage, the owner\n     *   not having enough shares, etc).\n     *\n     * NOTE: some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\n     * Those methods should be performed separately.\n     */\n    function redeem(uint256 shares, address receiver, address owner) external returns (uint256 assets);\n}\n"
    },
    "@openzeppelin/contracts/proxy/beacon/IBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {UpgradeableBeacon} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Utils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/ERC1967/ERC1967Utils.sol)\n\npragma solidity ^0.8.20;\n\nimport {IBeacon} from \"../beacon/IBeacon.sol\";\nimport {Address} from \"../../utils/Address.sol\";\nimport {StorageSlot} from \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n */\nlibrary ERC1967Utils {\n    // We re-declare ERC-1967 events here because they can't be used directly from IERC1967.\n    // This will be fixed in Solidity 0.8.21. At that point we should remove these events.\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Emitted when the beacon is changed.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev The `implementation` of the proxy is invalid.\n     */\n    error ERC1967InvalidImplementation(address implementation);\n\n    /**\n     * @dev The `admin` of the proxy is invalid.\n     */\n    error ERC1967InvalidAdmin(address admin);\n\n    /**\n     * @dev The `beacon` of the proxy is invalid.\n     */\n    error ERC1967InvalidBeacon(address beacon);\n\n    /**\n     * @dev An upgrade function sees `msg.value > 0` that may be lost.\n     */\n    error ERC1967NonPayable();\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        if (newImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(newImplementation);\n        }\n        StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Performs implementation upgrade with additional setup call if data is nonempty.\n     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected\n     * to avoid stuck value in the contract.\n     *\n     * Emits an {IERC1967-Upgraded} event.\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n\n        if (data.length > 0) {\n            Address.functionDelegateCall(newImplementation, data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using\n     * the https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n     */\n    function getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        if (newAdmin == address(0)) {\n            revert ERC1967InvalidAdmin(address(0));\n        }\n        StorageSlot.getAddressSlot(ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {IERC1967-AdminChanged} event.\n     */\n    function changeAdmin(address newAdmin) internal {\n        emit AdminChanged(getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is the keccak-256 hash of \"eip1967.proxy.beacon\" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        if (newBeacon.code.length == 0) {\n            revert ERC1967InvalidBeacon(newBeacon);\n        }\n\n        StorageSlot.getAddressSlot(BEACON_SLOT).value = newBeacon;\n\n        address beaconImplementation = IBeacon(newBeacon).implementation();\n        if (beaconImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(beaconImplementation);\n        }\n    }\n\n    /**\n     * @dev Change the beacon and trigger a setup call if data is nonempty.\n     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected\n     * to avoid stuck value in the contract.\n     *\n     * Emits an {IERC1967-BeaconUpgraded} event.\n     *\n     * CAUTION: Invoking this function has no effect on an instance of {BeaconProxy} since v5, since\n     * it uses an immutable beacon without looking at the value of the ERC-1967 beacon slot for\n     * efficiency.\n     */\n    function upgradeBeaconToAndCall(address newBeacon, bytes memory data) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n\n        if (data.length > 0) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n\n    /**\n     * @dev Reverts if `msg.value` is not zero. It can be used to avoid `msg.value` stuck in the contract\n     * if an upgrade doesn't perform an initialization call.\n     */\n    function _checkNonPayable() private {\n        if (msg.value > 0) {\n            revert ERC1967NonPayable();\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/StorageSlot.sol)\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```solidity\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(newImplementation.code.length > 0);\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Callback for IUniswapV3PoolActions#swap\n/// @notice Any contract that calls IUniswapV3PoolActions#swap must implement this interface\ninterface IUniswapV3SwapCallback {\n    /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.\n    /// @dev In the implementation you must pay the pool tokens owed for the swap.\n    /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\n    /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\n    /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n    /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n    /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call\n    function uniswapV3SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/IUniswapV3Factory.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title The interface for the Uniswap V3 Factory\n/// @notice The Uniswap V3 Factory facilitates creation of Uniswap V3 pools and control over the protocol fees\ninterface IUniswapV3Factory {\n    /// @notice Emitted when the owner of the factory is changed\n    /// @param oldOwner The owner before the owner was changed\n    /// @param newOwner The owner after the owner was changed\n    event OwnerChanged(address indexed oldOwner, address indexed newOwner);\n\n    /// @notice Emitted when a pool is created\n    /// @param token0 The first token of the pool by address sort order\n    /// @param token1 The second token of the pool by address sort order\n    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip\n    /// @param tickSpacing The minimum number of ticks between initialized ticks\n    /// @param pool The address of the created pool\n    event PoolCreated(\n        address indexed token0,\n        address indexed token1,\n        uint24 indexed fee,\n        int24 tickSpacing,\n        address pool\n    );\n\n    /// @notice Emitted when a new fee amount is enabled for pool creation via the factory\n    /// @param fee The enabled fee, denominated in hundredths of a bip\n    /// @param tickSpacing The minimum number of ticks between initialized ticks for pools created with the given fee\n    event FeeAmountEnabled(uint24 indexed fee, int24 indexed tickSpacing);\n\n    /// @notice Returns the current owner of the factory\n    /// @dev Can be changed by the current owner via setOwner\n    /// @return The address of the factory owner\n    function owner() external view returns (address);\n\n    /// @notice Returns the tick spacing for a given fee amount, if enabled, or 0 if not enabled\n    /// @dev A fee amount can never be removed, so this value should be hard coded or cached in the calling context\n    /// @param fee The enabled fee, denominated in hundredths of a bip. Returns 0 in case of unenabled fee\n    /// @return The tick spacing\n    function feeAmountTickSpacing(uint24 fee) external view returns (int24);\n\n    /// @notice Returns the pool address for a given pair of tokens and a fee, or address 0 if it does not exist\n    /// @dev tokenA and tokenB may be passed in either token0/token1 or token1/token0 order\n    /// @param tokenA The contract address of either token0 or token1\n    /// @param tokenB The contract address of the other token\n    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip\n    /// @return pool The pool address\n    function getPool(\n        address tokenA,\n        address tokenB,\n        uint24 fee\n    ) external view returns (address pool);\n\n    /// @notice Creates a pool for the given two tokens and fee\n    /// @param tokenA One of the two tokens in the desired pool\n    /// @param tokenB The other of the two tokens in the desired pool\n    /// @param fee The desired fee for the pool\n    /// @dev tokenA and tokenB may be passed in either order: token0/token1 or token1/token0. tickSpacing is retrieved\n    /// from the fee. The call will revert if the pool already exists, the fee is invalid, or the token arguments\n    /// are invalid.\n    /// @return pool The address of the newly created pool\n    function createPool(\n        address tokenA,\n        address tokenB,\n        uint24 fee\n    ) external returns (address pool);\n\n    /// @notice Updates the owner of the factory\n    /// @dev Must be called by the current owner\n    /// @param _owner The new owner of the factory\n    function setOwner(address _owner) external;\n\n    /// @notice Enables a fee amount with the given tickSpacing\n    /// @dev Fee amounts may never be removed once enabled\n    /// @param fee The fee amount to enable, denominated in hundredths of a bip (i.e. 1e-6)\n    /// @param tickSpacing The spacing between ticks to be enforced for all pools created with the given fee amount\n    function enableFeeAmount(uint24 fee, int24 tickSpacing) external;\n}\n"
    },
    "@uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.5;\npragma abicoder v2;\n\nimport '@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol';\n\n/// @title Router token swapping functionality\n/// @notice Functions for swapping tokens via Uniswap V3\ninterface ISwapRouter is IUniswapV3SwapCallback {\n    struct ExactInputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of another token\n    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);\n\n    struct ExactInputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut);\n\n    struct ExactOutputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Swaps as little as possible of one token for `amountOut` of another token\n    /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata\n    /// @return amountIn The amount of the input token\n    function exactOutputSingle(ExactOutputSingleParams calldata params) external payable returns (uint256 amountIn);\n\n    struct ExactOutputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n    }\n\n    /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata\n    /// @return amountIn The amount of the input token\n    function exactOutput(ExactOutputParams calldata params) external payable returns (uint256 amountIn);\n}\n"
    },
    "contracts/interfaces/IChainlinkAggregator.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\ninterface IChainlinkAggregator {\n    /**\n     * @notice Reads the current answer from aggregator delegated to.\n     */\n    function latestAnswer() external view returns (int256);\n\n    function decimals() external view returns (uint8);\n}\n"
    },
    "contracts/interfaces/IPoolingManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nstruct StrategyInfo {\n    address underlying;\n    address bridge;\n}\n\nstruct BridgeInteractionInfo {\n    address bridge;\n    uint256 amount;\n}\n\nstruct StrategyReportL2 {\n    address l1Strategy;\n    uint256 actionId;\n    uint256 amount;\n}\n\nstruct StrategyReportL1 {\n    address l1Strategy;\n    uint256 l1Nav;\n    uint256 amount;\n}\n\ninterface IPoolingManager {\n    // Events\n    event PendingRequestsExecuted(uint256[] indices);\n    event MessageResentToL2();\n    event BridgeCancelDepositRequestClaimedAndDeposited(\n        address l1BridgeAddress,\n        uint256 amount,\n        uint256 nonce\n    );\n    event CancelDepositRequestBridgeSent(\n        address l1BridgeAddress,\n        uint256 amount,\n        uint256 nonce\n    );\n    event ReportHandled(uint256 epoch, StrategyReportL1[] strategyReportL1);\n    event StrategyRegistered(address strategy, StrategyInfo strategyInfo);\n\n    // Functions\n    function initialize(\n        address _owner,\n        uint256 _l2PoolingManager,\n        address _starknetCore,\n        address _relayer\n    ) external;\n\n    function hashFromCalldata(\n        BridgeInteractionInfo[] calldata bridgeWithdrawInfo,\n        StrategyReportL2[] calldata strategyReportL2,\n        BridgeInteractionInfo[] calldata bridgeDepositInfo\n    ) external pure returns (uint256);\n\n    function hashFromReportL1(\n        uint256 epoch,\n        StrategyReportL1[] calldata strategyReportL1\n    ) external pure returns (uint256);\n\n    function bridgeEthFeesMultiplicator(\n        BridgeInteractionInfo[] calldata bridgeDepositInfo\n    ) external view returns (uint256);\n\n    function registerStrategy(\n        address _strategy,\n        address _underlying,\n        address _bridge\n    ) external payable;\n\n    function resendMessageToL2() external payable returns (uint256);\n\n    function cancelDepositRequestBridge(\n        address l1BridgeAddress,\n        uint256 amount,\n        uint256 nonce\n    ) external returns (uint256);\n\n    function claimBridgeCancelDepositRequestAndDeposit(\n        address l1BridgeAddress,\n        uint256 amount,\n        uint256 nonce,\n        uint256 l2BridgeEthFee\n    ) external payable;\n\n    function executePendingRequests() external;\n\n    function handleReport(\n        BridgeInteractionInfo[] calldata bridgeWithdrawInfo,\n        StrategyReportL2[] calldata strategyReportL2,\n        BridgeInteractionInfo[] calldata bridgeDepositInfo,\n        uint256 l2BridgeEthFee,\n        uint256 l2MessagingEthFee\n    ) external payable;\n}\n"
    },
    "contracts/interfaces/ISavingDai.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\nimport \"@openzeppelin/contracts/interfaces/IERC4626.sol\";\n\ninterface ISavingDai is IERC4626 {\n    function dai() external view returns (address);\n}\n"
    },
    "contracts/interfaces/IStarknetBridge.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\ninterface IStarknetBridge {\n    function deposit(uint256 amount, uint256 l2Recipient) external payable;\n\n    function withdraw(uint256 amount, address recipient) external;\n\n    function depositCancelRequest(\n        uint256 amount,\n        uint256 l2Recipient,\n        uint256 nonce\n    ) external;\n\n    function depositReclaim(\n        uint256 amount,\n        uint256 l2Recipient,\n        uint256 nonce\n    ) external;\n}\n"
    },
    "contracts/interfaces/IStarknetMessaging.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\ninterface IStarknetMessaging {\n    /// @notice Consumes a message that was sent from an L2 contract. Returns the hash of the message.\n    function consumeMessageFromL2(\n        uint256 fromAddress,\n        uint256[] calldata payload\n    ) external returns (bytes32);\n\n    /// @notice Execute a function call on L2\n    function sendMessageToL2(\n        uint256 toAddress,\n        uint256 selector,\n        uint256[] calldata payload\n    ) external payable returns (bytes32, uint256);\n\n    function l2ToL1Messages(bytes32 msgHash) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IStrategyBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nuint256 constant DEPOSIT = 0;\nuint256 constant REPORT = 1;\nuint256 constant WITHDRAW = 2;\n\ninterface IStrategyBase {\n    function initializeStrategyBase(\n        address _l2PoolingManager,\n        address _underlyingToken,\n        address _yieldToken\n    ) external;\n\n    function handleReport(\n        uint256 actionId,\n        uint256 amount\n    ) external payable returns (uint256, uint256);\n\n    function nav() external view returns (uint256);\n\n    function yieldToUnderlying(uint256 amount) external view returns (uint256);\n\n    function underlyingToYield(uint256 amount) external view returns (uint256);\n\n    function yieldBalance() external view returns (uint256);\n\n    function poolingManager() external view returns (address);\n}\n"
    },
    "contracts/interfaces/IStrategyUniswapV3.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nuint256 constant SLIPPAGE_PRECISION = 10 ** 18;\n"
    },
    "contracts/interfaces/IWETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\ninterface IWETH {\n    function deposit() external payable;\n\n    function transfer(address to, uint value) external returns (bool);\n\n    function withdraw(uint) external;\n}\n"
    },
    "contracts/interfaces/IWstETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\ninterface IWstETH {\n    /**\n     * @notice Get amount of stETH for a one wstETH\n     * @return Amount of stETH for 1 wstETH\n     */\n    function stEthPerToken() external view returns (uint256);\n}\n"
    },
    "contracts/lib/ErrorLib.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0.\npragma solidity ^0.8.20;\n\nlibrary ErrorLib {\n    error NotRelayer();\n    error UnknownUnderlying();\n    error ZeroAddress();\n    error InvalidEthAmount();\n    error InvalidCaller();\n    error UnknownActionId();\n    error InvalidSlippage();\n    error InvalidDecimals();\n    error InvalidPoolingManager();\n    error NoL1Report();\n    error NotEnoughSuccessCalls();\n}\n"
    },
    "contracts/lib/Messaging.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {IStarknetMessaging} from \"../interfaces/IStarknetMessaging.sol\";\nimport {IStarknetBridge} from \"../interfaces/IStarknetBridge.sol\";\n\n/// @title Messaging contract.\n/// @author Spaceshard team 2023.\ncontract Messaging {\n    uint256 private constant UINT256_PART_SIZE_BITS = 128;\n    uint256 private constant UINT256_PART_SIZE = 2 ** UINT256_PART_SIZE_BITS;\n\n    /// @notice Starknet messaging interface.\n    IStarknetMessaging public starknetCore;\n\n    /// @notice initialize the trove handler.\n    /// @param _starknetCore Starknet core interface.\n    function initializeMessaging(address _starknetCore) internal {\n        starknetCore = IStarknetMessaging(_starknetCore);\n    }\n\n    /// @notice Consume l2 message.\n    function _consumeL2Message(\n        uint256 l2ContractAddress,\n        uint256[] memory data\n    ) internal {\n        starknetCore.consumeMessageFromL2(l2ContractAddress, data);\n    }\n\n    /// @notice Withdraw tokens from Starkgate bridge.\n    function _withdrawTokenFromBridge(\n        address l1BridgeAddress,\n        address _receiver,\n        uint256 _amount\n    ) internal {\n        IStarknetBridge(l1BridgeAddress).withdraw(_amount, _receiver);\n    }\n\n    /// @notice deposit tokens to Starknet bridge.\n    function depositToBridgeToken(\n        address l1BridgeAddress,\n        uint256 _l2Receiver,\n        uint256 _amount,\n        uint256 _value\n    ) internal {\n        if (_amount > 0) {\n            IStarknetBridge(l1BridgeAddress).deposit{value: _value}(\n                _amount,\n                _l2Receiver\n            );\n        }\n    }\n\n    /// @notice cancel deposit tokens to Starknet bridge.\n    function depositCancelRequestToBridgeToken(\n        address l1BridgeAddress,\n        uint256 _l2Receiver,\n        uint256 _amount,\n        uint256 _nonce\n    ) internal {\n        if (_amount > 0) {\n            IStarknetBridge(l1BridgeAddress).depositCancelRequest(\n                _amount,\n                _l2Receiver,\n                _nonce\n            );\n        }\n    }\n\n    /// @notice cancel deposit tokens to Starknet bridge.\n    function depositReclaimToBridgeToken(\n        address l1BridgeAddress,\n        uint256 _l2Receiver,\n        uint256 _amount,\n        uint256 _nonce\n    ) internal {\n        if (_amount > 0) {\n            IStarknetBridge(l1BridgeAddress).depositReclaim(\n                _amount,\n                _l2Receiver,\n                _nonce\n            );\n        }\n    }\n\n    /// @notice send message to l2.\n    function _sendMessageToL2(\n        uint256 _l2Contract,\n        uint256 _selector,\n        uint256[] memory payload,\n        uint256 _value\n    ) internal {\n        starknetCore.sendMessageToL2{value: _value}(\n            _l2Contract,\n            _selector,\n            payload\n        );\n    }\n\n    function u256(\n        uint256 _value\n    ) internal pure returns (uint256 low, uint256 high) {\n        low = _value & (UINT256_PART_SIZE - 1);\n        high = _value >> UINT256_PART_SIZE_BITS;\n    }\n}\n"
    },
    "contracts/mock/poolingManager/poolingManagerMock.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.20;\n\nimport \"../../interfaces/IStrategyBase.sol\";\n\ninterface IPoolingManagerMock {\n    function handleReport(\n        address strategy,\n        uint256 actionId,\n        uint256 amount\n    ) external;\n\n    function hasRole(\n        bytes32 role,\n        address account\n    ) external view returns (bool);\n}\n\ncontract PoolingManagerMock is IPoolingManagerMock {\n    uint256 public lastNav;\n    uint256 public lastWithdrawalAmount;\n    address public owner;\n\n    constructor() {\n        owner = address(msg.sender);\n    }\n\n    function handleReport(\n        address strategy,\n        uint256 actionId,\n        uint256 amount\n    ) external {\n        (lastNav, lastWithdrawalAmount) = IStrategyBase(strategy).handleReport(\n            actionId,\n            amount\n        );\n    }\n\n    function hasRole(\n        bytes32 role,\n        address account\n    ) external view returns (bool) {\n        if (owner == address(account)) {\n            return (true);\n        } else {\n            return (false);\n        }\n    }\n}\n"
    },
    "contracts/mock/strategyBase/TestStrategyBase.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.20;\n\nimport \"../../strategies/StrategyBase.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IERC20Extended is IERC20 {\n    function mint(address account, uint256 amount) external;\n\n    function burn(address account, uint256 amount) external;\n}\n\ncontract TestStrategyBase is StrategyBase {\n    uint256 private _yieldFactor;\n    uint256 private constant PRECISION = 1e18;\n\n    function initialize(\n        address _poolingManager,\n        address _underlyingTokenAddress,\n        address _yieldTokenAddress,\n        uint256 yieldFactor\n    ) public virtual initializer {\n        initializeStrategyBase(\n            _poolingManager,\n            _underlyingTokenAddress,\n            _yieldTokenAddress\n        );\n        _yieldFactor = yieldFactor;\n    }\n\n    function _deposit(uint256 amount) internal override {\n        IERC20Extended _underlyingToken = IERC20Extended(underlyingToken);\n        IERC20Extended _yieldToken = IERC20Extended(yieldToken);\n        _underlyingToken.burn(address(this), amount);\n        uint256 yieldAmount = _underlyingToYield(amount);\n        _yieldToken.mint(address(this), yieldAmount);\n    }\n\n    function _withdraw(uint256 amount) internal override returns (uint256) {\n        IERC20Extended _underlyingToken = IERC20Extended(underlyingToken);\n        IERC20Extended _yieldToken = IERC20Extended(yieldToken);\n\n        uint256 yieldAmount = _underlyingToYield(amount);\n        _yieldToken.burn(address(this), yieldAmount);\n\n        _underlyingToken.mint(address(this), amount);\n        return amount;\n    }\n\n    function _yieldToUnderlying(\n        uint256 amount\n    ) internal view override returns (uint256) {\n        return (amount * PRECISION) / _yieldFactor;\n    }\n\n    function _underlyingToYield(\n        uint256 amount\n    ) internal view override returns (uint256) {\n        return (amount * _yieldFactor) / PRECISION;\n    }\n}\n"
    },
    "contracts/PoolingManager.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {AccessControlUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport {PausableUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\nimport {ErrorLib} from \"./lib/ErrorLib.sol\";\nimport {Messaging} from \"./lib/Messaging.sol\";\nimport \"./interfaces/IPoolingManager.sol\";\nimport {IWETH} from \"./interfaces/IWETH.sol\";\nimport {IStrategyBase} from \"./interfaces/IStrategyBase.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\n\ncontract PoolingManager is\n    UUPSUpgradeable,\n    AccessControlUpgradeable,\n    PausableUpgradeable,\n    ReentrancyGuardUpgradeable,\n    Messaging\n{\n    struct StrategyInfo {\n        address underlying;\n        address bridge;\n    }\n\n    uint256 public l2PoolingManager;\n    mapping(address => StrategyInfo) public strategyInfo;\n    uint256 public batchCounter;\n    address public ethBridge;\n    address public ethWrapped;\n    StrategyReportL2[] public pendingRequests;\n    StrategyReportL1[] public pendingRequestsExecuted;\n    uint256 public pendingRequestsExecutedCounter;\n\n    event PendingRequestsExecuted(uint256[] indices);\n    event MessageResentToL2();\n    event BridgeCancelDepositRequestClaimedAndDeposited(\n        address l1BridgeAddress,\n        uint256 amount,\n        uint256 nonce\n    );\n    event CancelDepositRequestBridgeSent(\n        address l1BridgeAddress,\n        uint256 amount,\n        uint256 nonce\n    );\n    event ReportHandled(uint256 epoch, StrategyReportL1[] strategyReportL1);\n    event StrategyRegistered(address strategy, StrategyInfo strategyInfo);\n\n    uint256 public constant L2_HANDLER_SELECTOR =\n        0x10e13e50cb99b6b3c8270ec6e16acfccbe1164a629d74b43549567a77593aff;\n    bytes32 public constant RELAYER_ROLE = keccak256(\"0x01\");\n\n    /**\n     * @dev Receive Ether function\n     */\n    receive() external payable {}\n\n    /**\n     * @dev Fallback function\n     */\n    fallback() external payable {}\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() initializer {}\n\n    /// @notice Initialier the contract state.\n    /// @param _l2PoolingManager troveManager address\n    /// @param _starknetCore starknetCore address\n    /// @param _relayer relayer address\n    function initialize(\n        address _owner,\n        uint256 _l2PoolingManager,\n        address _starknetCore,\n        address _relayer,\n        address _ethBridge,\n        address _ethWrapped\n    ) public initializer {\n        __Pausable_init();\n        __AccessControl_init();\n        __UUPSUpgradeable_init();\n        initializeMessaging(_starknetCore);\n        l2PoolingManager = _l2PoolingManager;\n        _grantRole(0, _owner);\n        _grantRole(RELAYER_ROLE, _owner);\n        _grantRole(RELAYER_ROLE, _relayer);\n        ethBridge = _ethBridge;\n        ethWrapped = _ethWrapped;\n    }\n\n    function hashFromReportL2(\n        uint256 epoch,\n        BridgeInteractionInfo[] memory bridgeWithdrawInfo,\n        StrategyReportL2[] memory strategyReportL2,\n        BridgeInteractionInfo[] memory bridgeDepositInfo\n    ) public pure returns (uint256) {\n        bytes memory encodedData = abi.encodePacked(epoch);\n\n        for (uint i = 0; i < bridgeWithdrawInfo.length; i++) {\n            encodedData = abi.encodePacked(\n                encodedData,\n                uint256(uint160(bridgeWithdrawInfo[i].bridge)),\n                bridgeWithdrawInfo[i].amount\n            );\n        }\n\n        for (uint i = 0; i < strategyReportL2.length; i++) {\n            encodedData = abi.encodePacked(\n                encodedData,\n                uint256(uint160(strategyReportL2[i].l1Strategy)),\n                strategyReportL2[i].actionId,\n                strategyReportL2[i].amount\n            );\n        }\n\n        for (uint i = 0; i < bridgeDepositInfo.length; i++) {\n            encodedData = abi.encodePacked(\n                encodedData,\n                uint256(uint160(bridgeDepositInfo[i].bridge)),\n                bridgeDepositInfo[i].amount\n            );\n        }\n\n        uint256 hashValue = uint256(keccak256(encodedData));\n        return hashValue;\n    }\n\n    function hashFromReportL1(\n        StrategyReportL1[] memory strategyReportL1\n    ) public pure returns (uint256) {\n        bytes memory encodedData = abi.encodePacked();\n        for (uint i = 0; i < strategyReportL1.length; i++) {\n            encodedData = abi.encodePacked(\n                encodedData,\n                uint256(uint160(strategyReportL1[i].l1Strategy)),\n                strategyReportL1[i].l1Nav,\n                strategyReportL1[i].amount\n            );\n        }\n\n        uint256 strategyReportL1Hash = uint256(keccak256(encodedData));\n        return strategyReportL1Hash;\n    }\n\n    function bridgeEthFeesMultiplicator(\n        BridgeInteractionInfo[] memory bridgeDepositInfo\n    ) public view returns (uint256) {\n        uint256 acc = 0;\n        for (\n            uint256 index1 = 0;\n            index1 < pendingRequestsExecuted.length;\n            index1++\n        ) {\n            StrategyReportL1\n                memory pendingRequestsExecutedElem = pendingRequestsExecuted[\n                    index1\n                ];\n            if (pendingRequestsExecutedElem.amount > 0) {\n                bool found = false;\n                for (\n                    uint256 index2 = 0;\n                    index2 < bridgeDepositInfo.length;\n                    index2++\n                ) {\n                    BridgeInteractionInfo\n                        memory bridgeDepositInfoElem = bridgeDepositInfo[\n                            index2\n                        ];\n                    if (\n                        bridgeDepositInfoElem.bridge ==\n                        strategyInfo[pendingRequestsExecutedElem.l1Strategy]\n                            .bridge\n                    ) {\n                        found = true;\n                    }\n                }\n                if (!found) {\n                    acc++;\n                }\n            }\n        }\n        return (bridgeDepositInfo.length + acc);\n    }\n\n    function registerStrategy(\n        address _strategy,\n        address _underlying,\n        address _bridge\n    ) public payable onlyRole(0) {\n        if (_underlying == address(0)) revert ErrorLib.ZeroAddress();\n        if (_bridge == address(0)) revert ErrorLib.ZeroAddress();\n        if (_strategy == address(0)) revert ErrorLib.ZeroAddress();\n\n        if (IStrategyBase(_strategy).poolingManager() != address(this))\n            revert ErrorLib.InvalidPoolingManager();\n\n        StrategyInfo memory newStrategyInfo = StrategyInfo({\n            underlying: _underlying,\n            bridge: _bridge\n        });\n        strategyInfo[_strategy] = newStrategyInfo;\n\n        IERC20(_underlying).approve(_bridge, type(uint256).max);\n        emit StrategyRegistered(_strategy, newStrategyInfo);\n    }\n\n    function setPoolingManager(\n        uint256 _l2PoolingManager\n    ) public payable onlyRole(0) {\n        if (_l2PoolingManager == (0)) revert ErrorLib.ZeroAddress();\n        l2PoolingManager = _l2PoolingManager;\n    }\n\n    function cancelDepositRequestBridge(\n        address l1BridgeAddress,\n        uint256 amount,\n        uint256 nonce\n    ) public onlyRole(0) {\n        depositCancelRequestToBridgeToken(\n            l1BridgeAddress,\n            l2PoolingManager,\n            amount,\n            nonce\n        );\n        emit CancelDepositRequestBridgeSent(l1BridgeAddress, amount, nonce);\n    }\n\n    function claimBridgeCancelDepositRequestAndDeposit(\n        address l1BridgeAddress,\n        uint256 amount,\n        uint256 nonce,\n        uint256 l2BridgeEthFee\n    ) public payable onlyRole(0) {\n        depositReclaimToBridgeToken(\n            l1BridgeAddress,\n            l2PoolingManager,\n            amount,\n            nonce\n        );\n        BridgeInteractionInfo[]\n            memory bridgeElemArray = new BridgeInteractionInfo[](1);\n        bridgeElemArray[0] = BridgeInteractionInfo({\n            bridge: l1BridgeAddress,\n            amount: amount\n        });\n        depositToBridges(bridgeElemArray, l2BridgeEthFee, false);\n        emit BridgeCancelDepositRequestClaimedAndDeposited(\n            l1BridgeAddress,\n            amount,\n            nonce\n        );\n    }\n\n    function pause() external onlyRole(RELAYER_ROLE) {\n        _pause();\n    }\n\n    function unpause() external onlyRole(0) {\n        _unpause();\n    }\n\n    function executePendingRequests() public onlyRole(RELAYER_ROLE) {\n        uint256[] memory indicesToDelete = new uint256[](\n            pendingRequests.length\n        );\n        uint256 indicesToDeleteLength = 0;\n        for (uint256 index = 0; index < pendingRequests.length; index++) {\n            StrategyReportL2 memory currentReport = pendingRequests[index];\n            try\n                IStrategyBase(currentReport.l1Strategy).handleReport(\n                    currentReport.actionId,\n                    currentReport.amount\n                )\n            returns (uint256 l1Nav, uint256 amount) {\n                indicesToDelete[indicesToDeleteLength] = index;\n                indicesToDeleteLength++;\n                pendingRequestsExecuted.push(\n                    StrategyReportL1({\n                        l1Strategy: currentReport.l1Strategy,\n                        l1Nav: l1Nav,\n                        amount: amount\n                    })\n                );\n            } catch {}\n        }\n\n        for (uint256 i = indicesToDeleteLength; i > 0; i--) {\n            deleteElement(pendingRequests, indicesToDelete[i - 1]);\n        }\n        emit PendingRequestsExecuted(indicesToDelete);\n    }\n\n    function handleReport(\n        uint256 epoch,\n        BridgeInteractionInfo[] memory bridgeWithdrawInfo,\n        StrategyReportL2[] memory strategyReportL2,\n        BridgeInteractionInfo[] memory bridgeDepositInfo,\n        uint256 l2BridgeEthFee,\n        uint256 l2MessagingEthFee,\n        uint256 minSuccessCall\n    ) public payable onlyRole(RELAYER_ROLE) whenNotPaused {\n        verifyCallData(\n            epoch,\n            bridgeWithdrawInfo,\n            strategyReportL2,\n            bridgeDepositInfo\n        );\n        withdrawFromBridges(bridgeWithdrawInfo);\n        (\n            uint256 strategyReportL1Length,\n            StrategyReportL1[] memory strategyReportL1,\n            BridgeInteractionInfo[] memory newBridgeDepositInfo\n        ) = handleMassReport(strategyReportL2, bridgeDepositInfo);\n\n        if (strategyReportL1Length == 0) revert ErrorLib.NoL1Report();\n        if (minSuccessCall > strategyReportL1Length)\n            revert ErrorLib.NotEnoughSuccessCalls();\n\n        depositToBridges(newBridgeDepositInfo, l2BridgeEthFee, true);\n\n        uint256 strategyReportL1Hash = hashFromReportL1(strategyReportL1);\n        uint256[] memory data = getMessagePayloadData(\n            epoch,\n            strategyReportL1Hash\n        );\n\n        _sendMessageToL2(\n            l2PoolingManager,\n            L2_HANDLER_SELECTOR,\n            data,\n            l2MessagingEthFee\n        );\n\n        emit ReportHandled(epoch, strategyReportL1);\n    }\n\n    function getMessagePayloadData(\n        uint256 epoch,\n        uint256 strategyReportL1Hash\n    ) internal returns (uint256[] memory) {\n        (uint256 lowEpoch, uint256 highEpoch) = u256(epoch);\n        (\n            uint256 lowStrategyReportL1Hash,\n            uint256 highStrategyReportL1Hash\n        ) = u256(strategyReportL1Hash);\n\n        uint256[] memory data = new uint256[](4);\n        data[0] = lowEpoch;\n        data[1] = highEpoch;\n        data[2] = lowStrategyReportL1Hash;\n        data[3] = highStrategyReportL1Hash;\n        return (data);\n    }\n\n    function deleteElement(\n        StrategyReportL2[] storage array,\n        uint256 index\n    ) internal {\n        require(index < array.length, \"Index out of bounds\");\n        array[index] = array[array.length - 1];\n        array.pop();\n    }\n\n    function verifyCallData(\n        uint256 epoch,\n        BridgeInteractionInfo[] memory bridgeWithdrawInfo,\n        StrategyReportL2[] memory strategyReportL2,\n        BridgeInteractionInfo[] memory bridgeDepositInfo\n    ) internal {\n        uint256 hash_from_calldata = hashFromReportL2(\n            epoch,\n            bridgeWithdrawInfo,\n            strategyReportL2,\n            bridgeDepositInfo\n        );\n        (uint256 lowHash, uint256 highHash) = u256(hash_from_calldata);\n        uint256[] memory data = new uint256[](2);\n        data[0] = lowHash;\n        data[1] = highHash;\n        _consumeL2Message(l2PoolingManager, data);\n    }\n\n    function withdrawFromBridges(\n        BridgeInteractionInfo[] memory bridgeWithdrawalInfo\n    ) internal {\n        for (uint256 index = 0; index < bridgeWithdrawalInfo.length; index++) {\n            _withdrawTokenFromBridge(\n                bridgeWithdrawalInfo[index].bridge,\n                address(this),\n                bridgeWithdrawalInfo[index].amount\n            );\n            if (bridgeWithdrawalInfo[index].bridge == ethBridge) {\n                IWETH(ethWrapped).deposit{\n                    value: bridgeWithdrawalInfo[index].amount\n                }();\n            }\n        }\n    }\n\n    function depositToBridges(\n        BridgeInteractionInfo[] memory bridgeDepositInfo,\n        uint256 l2BridgeEthFee,\n        bool withdrawEth\n    ) internal {\n        for (uint256 index = 0; index < bridgeDepositInfo.length; index++) {\n            BridgeInteractionInfo\n                memory bridgeInteractionInfoElem = bridgeDepositInfo[index];\n            if (bridgeInteractionInfoElem.bridge == ethBridge) {\n                if (withdrawEth) {\n                    IWETH(ethWrapped).withdraw(\n                        bridgeInteractionInfoElem.amount\n                    );\n                }\n                depositToBridgeToken(\n                    bridgeInteractionInfoElem.bridge,\n                    l2PoolingManager,\n                    bridgeInteractionInfoElem.amount,\n                    bridgeInteractionInfoElem.amount + l2BridgeEthFee\n                );\n            } else {\n                depositToBridgeToken(\n                    bridgeInteractionInfoElem.bridge,\n                    l2PoolingManager,\n                    bridgeInteractionInfoElem.amount,\n                    l2BridgeEthFee\n                );\n            }\n        }\n    }\n\n    function handleMassReport(\n        StrategyReportL2[] memory strategyReportL2,\n        BridgeInteractionInfo[] memory bridgeDepositInfo\n    )\n        internal\n        returns (\n            uint256,\n            StrategyReportL1[] memory,\n            BridgeInteractionInfo[] memory\n        )\n    {\n        (\n            uint256 strategyReportL1Length,\n            StrategyReportL1[] memory strategyReportL1,\n            uint256 tempBridgeLossLength,\n            BridgeInteractionInfo[] memory tempBridgeLoss\n        ) = processStrategyReports(strategyReportL2);\n\n        updateBridgeDepositInfo(\n            tempBridgeLossLength,\n            tempBridgeLoss,\n            bridgeDepositInfo\n        );\n\n        uint256 pendingRequestsExecutedLength = pendingRequestsExecuted.length -\n            pendingRequestsExecutedCounter;\n\n        if (pendingRequestsExecutedLength > 0) {\n            return\n                processPendingRequests(\n                    strategyReportL1Length,\n                    strategyReportL1,\n                    bridgeDepositInfo,\n                    pendingRequestsExecutedLength\n                );\n        } else {\n            return (\n                strategyReportL1Length,\n                strategyReportL1,\n                bridgeDepositInfo\n            );\n        }\n    }\n\n    function processStrategyReports(\n        StrategyReportL2[] memory strategyReportL2\n    )\n        internal\n        returns (\n            uint256 strategyReportL1Length,\n            StrategyReportL1[] memory strategyReportL1,\n            uint256 tempBridgeLossLength,\n            BridgeInteractionInfo[] memory tempBridgeLoss\n        )\n    {\n        strategyReportL1 = new StrategyReportL1[](strategyReportL2.length);\n        tempBridgeLoss = new BridgeInteractionInfo[](\n            strategyReportL2.length + pendingRequestsExecuted.length\n        );\n\n        for (uint256 i = 0; i < strategyReportL2.length; i++) {\n            StrategyReportL2 memory currentReport = strategyReportL2[i];\n            StrategyInfo memory currentStrategyInfo = strategyInfo[\n                currentReport.l1Strategy\n            ];\n\n            if (currentReport.actionId == 0) {\n                IERC20(currentStrategyInfo.underlying).transfer(\n                    currentReport.l1Strategy,\n                    currentReport.amount\n                );\n            }\n\n            try\n                IStrategyBase(currentReport.l1Strategy).handleReport(\n                    currentReport.actionId,\n                    currentReport.amount\n                )\n            returns (uint256 l1Nav, uint256 amount) {\n                strategyReportL1[strategyReportL1Length] = StrategyReportL1({\n                    l1Strategy: currentReport.l1Strategy,\n                    l1Nav: l1Nav,\n                    amount: amount\n                });\n                if (\n                    currentReport.actionId == 2 &&\n                    amount != currentReport.amount\n                ) {\n                    tempBridgeLoss[\n                        tempBridgeLossLength\n                    ] = BridgeInteractionInfo({\n                        bridge: currentStrategyInfo.bridge,\n                        amount: currentReport.amount - amount\n                    });\n                    tempBridgeLossLength++;\n                }\n                strategyReportL1Length++;\n            } catch {\n                pendingRequests.push(currentReport);\n                tempBridgeLoss[tempBridgeLossLength] = BridgeInteractionInfo({\n                    bridge: currentStrategyInfo.bridge,\n                    amount: currentReport.amount\n                });\n                tempBridgeLossLength++;\n            }\n        }\n\n        return (\n            strategyReportL1Length,\n            strategyReportL1,\n            tempBridgeLossLength,\n            tempBridgeLoss\n        );\n    }\n\n    function processPendingRequests(\n        uint256 strategyReportL1Length,\n        StrategyReportL1[] memory strategyReportL1,\n        BridgeInteractionInfo[] memory bridgeDepositInfo,\n        uint256 pendingRequestsExecutedLength\n    )\n        internal\n        returns (\n            uint256,\n            StrategyReportL1[] memory,\n            BridgeInteractionInfo[] memory\n        )\n    {\n        (\n            uint256 newStrategyReportL1Length,\n            StrategyReportL1[] memory newStrategyReportL1,\n            uint256 tempBridgeAdditionalDepositLength,\n            BridgeInteractionInfo[] memory tempBridgeAdditionalDeposit\n        ) = mergeReportsAndUpdateDeposits(\n                strategyReportL1Length,\n                strategyReportL1,\n                bridgeDepositInfo,\n                pendingRequestsExecutedLength\n            );\n\n        pendingRequestsExecutedCounter = pendingRequestsExecuted.length;\n\n        if (tempBridgeAdditionalDepositLength > 0) {\n            uint256 totalLen = tempBridgeAdditionalDepositLength +\n                bridgeDepositInfo.length;\n\n            BridgeInteractionInfo[]\n                memory newBridgeDepositInfo = new BridgeInteractionInfo[](\n                    totalLen\n                );\n\n            for (uint256 i = 0; i < totalLen; i++) {\n                if (i < bridgeDepositInfo.length) {\n                    newBridgeDepositInfo[i] = bridgeDepositInfo[i];\n                } else {\n                    newBridgeDepositInfo[i] = tempBridgeAdditionalDeposit[\n                        i - bridgeDepositInfo.length\n                    ];\n                }\n            }\n            return (\n                newStrategyReportL1Length,\n                newStrategyReportL1,\n                newBridgeDepositInfo\n            );\n        } else {\n            return (\n                newStrategyReportL1Length,\n                newStrategyReportL1,\n                bridgeDepositInfo\n            );\n        }\n    }\n\n    function mergeReportsAndUpdateDeposits(\n        uint256 strategyReportL1Length,\n        StrategyReportL1[] memory strategyReportL1,\n        BridgeInteractionInfo[] memory bridgeDepositInfo,\n        uint256 pendingRequestsExecutedLength\n    )\n        internal\n        returns (\n            uint256 newStrategyReportL1Length,\n            StrategyReportL1[] memory newStrategyReportL1,\n            uint256 tempBridgeAdditionalDepositLength,\n            BridgeInteractionInfo[] memory tempBridgeAdditionalDeposit\n        )\n    {\n        newStrategyReportL1Length =\n            strategyReportL1Length +\n            pendingRequestsExecutedLength;\n        newStrategyReportL1 = new StrategyReportL1[](newStrategyReportL1Length);\n        tempBridgeAdditionalDeposit = new BridgeInteractionInfo[](\n            pendingRequestsExecutedLength\n        );\n\n        for (uint256 i = 0; i < newStrategyReportL1Length; i++) {\n            if (i < strategyReportL1Length) {\n                newStrategyReportL1[i] = strategyReportL1[i];\n            } else {\n                tempBridgeAdditionalDepositLength = processPendingRequest(\n                    i,\n                    strategyReportL1Length,\n                    newStrategyReportL1,\n                    bridgeDepositInfo,\n                    tempBridgeAdditionalDeposit,\n                    tempBridgeAdditionalDepositLength\n                );\n            }\n        }\n\n        return (\n            newStrategyReportL1Length,\n            newStrategyReportL1,\n            tempBridgeAdditionalDepositLength,\n            tempBridgeAdditionalDeposit\n        );\n    }\n\n    function processPendingRequest(\n        uint256 i,\n        uint256 strategyReportL1Length,\n        StrategyReportL1[] memory newStrategyReportL1,\n        BridgeInteractionInfo[] memory bridgeDepositInfo,\n        BridgeInteractionInfo[] memory tempBridgeAdditionalDeposit,\n        uint256 tempBridgeAdditionalDepositLength\n    ) internal returns (uint256) {\n        uint256 indexCounter = i - strategyReportL1Length;\n        StrategyReportL1\n            memory pendingRequestExecutedElem = pendingRequestsExecuted[\n                indexCounter\n            ];\n        newStrategyReportL1[i] = pendingRequestExecutedElem;\n\n        if (pendingRequestExecutedElem.amount > 0) {\n            StrategyInfo memory currentStrategyInfo = strategyInfo[\n                pendingRequestExecutedElem.l1Strategy\n            ];\n            bool found = false;\n            for (uint256 index = 0; index < bridgeDepositInfo.length; index++) {\n                if (\n                    bridgeDepositInfo[index].bridge ==\n                    currentStrategyInfo.bridge\n                ) {\n                    bridgeDepositInfo[index]\n                        .amount += pendingRequestExecutedElem.amount;\n                    found = true;\n                    break;\n                }\n            }\n            if (!found) {\n                tempBridgeAdditionalDeposit[\n                    tempBridgeAdditionalDepositLength\n                ] = BridgeInteractionInfo({\n                    bridge: currentStrategyInfo.bridge,\n                    amount: pendingRequestExecutedElem.amount\n                });\n                tempBridgeAdditionalDepositLength++;\n            }\n        }\n\n        return tempBridgeAdditionalDepositLength;\n    }\n\n    function _authorizeUpgrade(\n        address newImplementation\n    ) internal override onlyRole(0) {}\n\n    function updateBridgeDepositInfo(\n        uint256 tempBridgeLossLength,\n        BridgeInteractionInfo[] memory tempBridgeLoss,\n        BridgeInteractionInfo[] memory bridgeDepositInfo\n    ) internal pure {\n        for (uint256 index1 = 0; index1 < tempBridgeLossLength; index1++) {\n            BridgeInteractionInfo memory tempBridgeLossElem = tempBridgeLoss[\n                index1\n            ];\n            for (\n                uint256 index2 = 0;\n                index2 < bridgeDepositInfo.length;\n                index2++\n            ) {\n                if (\n                    tempBridgeLossElem.bridge ==\n                    bridgeDepositInfo[index2].bridge\n                ) {\n                    bridgeDepositInfo[index2].amount -= tempBridgeLossElem\n                        .amount;\n                    break;\n                }\n            }\n        }\n    }\n}\n"
    },
    "contracts/pricefeed/wsteth.sol": {
      "content": "pragma solidity ^0.8.20;\n\nimport {IChainlinkAggregator} from \"../interfaces/IChainlinkAggregator.sol\";\nimport {IWstETH} from \"../interfaces/IWstETH.sol\";\n\n/// @title wstETH/ETH price feed compatible with AAVE feed interface.\n/// @dev Please notice that this feed doesn't provide the complete Chainlink feed interface.\ncontract AAVECompatWstETHToETHPriceFeed is IChainlinkAggregator {\n    IWstETH public immutable wstETH;\n    IChainlinkAggregator public immutable stETHToETHPriceFeed;\n\n    int256 internal constant PRECISION = 10 ** 18;\n\n    constructor(address _stETHToETHPriceFeed, address _wstETH) {\n        stETHToETHPriceFeed = IChainlinkAggregator(_stETHToETHPriceFeed);\n        wstETH = IWstETH(_wstETH);\n    }\n\n    /**\n     * @notice Get price of one wstETH expressed in ETH.\n     */\n    function latestAnswer() external view override returns (int256) {\n        int256 wstETHToStETH = int256(wstETH.stEthPerToken());\n        assert(wstETHToStETH > 0);\n        int256 stETHToETH = stETHToETHPriceFeed.latestAnswer();\n\n        return (wstETHToStETH * stETHToETH) / PRECISION;\n    }\n\n    function decimals() external view override returns (uint8) {\n        return (18);\n    }\n\n    /**\n     * @notice Revert all calls except the 'latestAnswer'\n     */\n    fallback() external {\n        revert(\"Unexpected function call.\");\n    }\n}\n"
    },
    "contracts/strategies/savingDai/savingDai.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.20;\n\nimport {StrategyBase} from \"../StrategyBase.sol\";\nimport {ErrorLib} from \"../../lib/ErrorLib.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {ISavingDai} from \"../../interfaces/ISavingDai.sol\";\n\ncontract SavingDaiStrategy is StrategyBase {\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() initializer {}\n\n    function initialize(\n        address _poolingManager,\n        address _underlyingToken,\n        address _yieldToken\n    ) public virtual initializer {\n        initializeStrategyBase(_poolingManager, _underlyingToken, _yieldToken);\n        _checkAndInitSavingDai(_underlyingToken, _yieldToken);\n    }\n\n    function _checkAndInitSavingDai(\n        address _underlyingToken,\n        address _yieldToken\n    ) internal {\n        address dai = ISavingDai(_yieldToken).dai();\n        require(\n            dai == _underlyingToken,\n            \"Invalid underlying: Saving Dai Strategy\"\n        );\n        IERC20(_underlyingToken).approve(_yieldToken, type(uint256).max);\n    }\n\n    function _deposit(uint256 amount) internal override {\n        ISavingDai(yieldToken).deposit(amount, address(this));\n    }\n\n    function _withdraw(uint256 amount) internal override returns (uint256) {\n        uint256 yieldAmountToDeposit = ISavingDai(yieldToken).previewWithdraw(\n            amount\n        );\n        uint256 yieldBalance = yieldBalance();\n        if (yieldAmountToDeposit > yieldBalance) {\n            uint256 assets = ISavingDai(yieldToken).redeem(\n                yieldBalance,\n                poolingManager,\n                address(this)\n            );\n            return (assets);\n        } else {\n            uint256 assets = ISavingDai(yieldToken).withdraw(\n                amount,\n                poolingManager,\n                address(this)\n            );\n            return (amount);\n        }\n    }\n\n    function _underlyingToYield(\n        uint256 amount\n    ) internal view override returns (uint256) {\n        return ISavingDai(yieldToken).previewDeposit(amount);\n    }\n\n    function _yieldToUnderlying(\n        uint256 amount\n    ) internal view override returns (uint256) {\n        return ISavingDai(yieldToken).previewRedeem(amount);\n    }\n}\n"
    },
    "contracts/strategies/StrategyBase.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.20;\n\nimport {PausableUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../interfaces/IStrategyBase.sol\";\nimport {IAccessControl} from \"@openzeppelin/contracts/access/IAccessControl.sol\";\nimport \"../lib/ErrorLib.sol\";\n\nabstract contract StrategyBase is\n    Initializable,\n    PausableUpgradeable,\n    IStrategyBase\n{\n    address public poolingManager;\n    address public underlyingToken;\n    address public yieldToken;\n\n    function initializeStrategyBase(\n        address _l2PoolingManager,\n        address _underlyingToken,\n        address _yieldToken\n    ) public initializer {\n        __Pausable_init();\n        if (_l2PoolingManager == address(0)) revert ErrorLib.ZeroAddress();\n        if (_underlyingToken == address(0)) revert ErrorLib.ZeroAddress();\n        if (_yieldToken == address(0)) revert ErrorLib.ZeroAddress();\n        poolingManager = _l2PoolingManager;\n        underlyingToken = _underlyingToken;\n        yieldToken = _yieldToken;\n    }\n\n    function handleReport(\n        uint256 actionId,\n        uint256 amount\n    ) external payable override whenNotPaused returns (uint256, uint256) {\n        _assertOnlyPoolingManager();\n        uint256 withdrawalAmount = 0;\n        if (actionId == DEPOSIT) {\n            _deposit(amount);\n        } else if (actionId == WITHDRAW) {\n            withdrawalAmount = _withdraw(amount);\n            // Transfer to pooling manager should be implemented in _withdraw()\n        } else if (actionId == REPORT) {} else {\n            revert ErrorLib.UnknownActionId();\n        }\n        return (_nav(), withdrawalAmount);\n    }\n\n    function nav() public view returns (uint256) {\n        return _nav();\n    }\n\n    function yieldToUnderlying(uint256 amount) public view returns (uint256) {\n        return _yieldToUnderlying(amount);\n    }\n\n    function underlyingToYield(uint256 amount) public view returns (uint256) {\n        return _underlyingToYield(amount);\n    }\n\n    function yieldBalance() public view returns (uint256) {\n        return IERC20(yieldToken).balanceOf(address(this));\n    }\n\n    function _assertOnlyPoolingManager() internal view {\n        if (address(msg.sender) != poolingManager)\n            revert ErrorLib.InvalidCaller();\n    }\n\n    function _assertOnlyRoleOwner() internal view {\n        if (!IAccessControl(poolingManager).hasRole(0, address(msg.sender)))\n            revert ErrorLib.InvalidCaller();\n    }\n\n    function _deposit(uint256 amount) internal virtual;\n\n    function _withdraw(uint256 amount) internal virtual returns (uint256);\n\n    function _nav() internal view returns (uint256) {\n        return _yieldToUnderlying(yieldBalance());\n    }\n\n    function _yieldToUnderlying(\n        uint256 amount\n    ) internal view virtual returns (uint256);\n\n    function _underlyingToYield(\n        uint256 amount\n    ) internal view virtual returns (uint256);\n}\n"
    },
    "contracts/strategies/uniswap/uniswapV3.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.20;\n\nimport {StrategyBase} from \"../StrategyBase.sol\";\nimport {IChainlinkAggregator} from \"../../interfaces/IChainlinkAggregator.sol\";\nimport \"../../interfaces/IStrategyUniswapV3.sol\";\nimport {ErrorLib} from \"../../lib/ErrorLib.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol\";\nimport \"@uniswap/v3-core/contracts/interfaces/IUniswapV3Factory.sol\";\n\ncontract UniswapV3Strategy is StrategyBase {\n    ISwapRouter public uniswapRouter;\n    IChainlinkAggregator public chainlinkPricefeed;\n    uint256 public pricefeedPrecision;\n    uint256 public minReceivedAmountFactor;\n    uint24 public poolFee;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() initializer {}\n\n    function initialize(\n        address _poolingManager,\n        address _underlyingToken,\n        address _yieldToken,\n        address _uniswapRouter,\n        address _uniswapFactory,\n        address _chainlinkPricefeed,\n        uint256 _minReceivedAmountFactor,\n        uint24 _poolFee\n    ) public virtual initializer {\n        initializeStrategyBase(_poolingManager, _underlyingToken, _yieldToken);\n        _initializeUniswap(\n            _uniswapRouter,\n            _uniswapFactory,\n            _underlyingToken,\n            _yieldToken,\n            _poolFee\n        );\n        _initializeChainlink(_chainlinkPricefeed);\n        _setSlippage(_minReceivedAmountFactor);\n        _checkDecimals(_underlyingToken, _yieldToken);\n    }\n\n    function setMinReceivedAmountFactor(\n        uint256 _minReceivedAmountFactor\n    ) public {\n        _assertOnlyRoleOwner();\n        _setSlippage(_minReceivedAmountFactor);\n    }\n\n    function chainlinkLatestAnswer() public view returns (int256) {\n        return _chainlinkLatestAnswer();\n    }\n\n    function applySlippageDepositExactInputSingle(\n        uint256 amount\n    ) public view returns (uint256) {\n        return _applySlippageDepositExactInputSingle(amount);\n    }\n\n    function applySlippageWithdrawExactOutputSingle(\n        uint256 amount\n    ) public view returns (uint256) {\n        return _applySlippageWithdrawExactOutputSingle(amount);\n    }\n\n    function _initializeUniswap(\n        address _uniswapRouterAddress,\n        address _uniswapFactoryAddress,\n        address _underlyingToken,\n        address _yieldToken,\n        uint24 _poolFee\n    ) internal {\n        require(\n            _uniswapRouterAddress != address(0),\n            \"Zero address: Uniswap Router\"\n        );\n        uniswapRouter = ISwapRouter(_uniswapRouterAddress);\n\n        IUniswapV3Factory uniswapFactory = IUniswapV3Factory(\n            _uniswapFactoryAddress\n        );\n        address poolAddress = uniswapFactory.getPool(\n            _underlyingToken,\n            _yieldToken,\n            _poolFee\n        );\n        require(poolAddress != address(0), \"Pool does not exist\");\n        poolFee = _poolFee;\n\n        IERC20(_underlyingToken).approve(\n            _uniswapRouterAddress,\n            type(uint256).max\n        );\n\n        IERC20(_yieldToken).approve(_uniswapRouterAddress, type(uint256).max);\n    }\n\n    function _initializeChainlink(address chainlinkPricefeedAddress) internal {\n        require(\n            chainlinkPricefeedAddress != address(0),\n            \"Zero address: Chainlink\"\n        );\n        chainlinkPricefeed = IChainlinkAggregator(chainlinkPricefeedAddress);\n        pricefeedPrecision = 10 ** chainlinkPricefeed.decimals();\n    }\n\n    function _setSlippage(uint256 _minReceivedAmountFactor) internal {\n        require(\n            _minReceivedAmountFactor <= SLIPPAGE_PRECISION &&\n                _minReceivedAmountFactor >= (SLIPPAGE_PRECISION * 95) / 100,\n            \"Invalid slippage\"\n        );\n        minReceivedAmountFactor = _minReceivedAmountFactor;\n    }\n\n    function _checkDecimals(\n        address _underlyingToken,\n        address _yieldToken\n    ) internal virtual {\n        if (\n            IERC20Metadata(_underlyingToken).decimals() !=\n            IERC20Metadata(_yieldToken).decimals()\n        ) revert ErrorLib.InvalidDecimals();\n    }\n\n    function _deposit(uint256 amount) internal override {\n        uint256 yieldAmount = _underlyingToYield(amount);\n        uint256 amountOutMinimum = _applySlippageDepositExactInputSingle(\n            yieldAmount\n        );\n        ISwapRouter.ExactInputSingleParams memory params = ISwapRouter\n            .ExactInputSingleParams({\n                tokenIn: underlyingToken,\n                tokenOut: yieldToken,\n                fee: poolFee,\n                recipient: address(this),\n                deadline: block.timestamp,\n                amountIn: amount,\n                amountOutMinimum: amountOutMinimum,\n                sqrtPriceLimitX96: 0\n            });\n\n        uniswapRouter.exactInputSingle(params);\n    }\n\n    function _withdraw(uint256 amount) internal override returns (uint256) {\n        uint256 chainlinkLatestAnswer = uint256(_chainlinkLatestAnswer());\n        uint256 yieldAmount = _calculateUnderlyingToYieldAmount(\n            chainlinkLatestAnswer,\n            amount\n        );\n        uint256 amountInMaximum = _applySlippageWithdrawExactOutputSingle(\n            yieldAmount\n        );\n        uint256 yieldBalance = yieldBalance();\n\n        if (amountInMaximum > yieldBalance) {\n            uint256 underlyingAmount = _calculateYieldToUnderlyingAmount(\n                chainlinkLatestAnswer,\n                yieldBalance\n            );\n            uint256 amountOutMinimum = _applySlippageDepositExactInputSingle(\n                underlyingAmount\n            );\n            ISwapRouter.ExactInputSingleParams memory params = ISwapRouter\n                .ExactInputSingleParams({\n                    tokenIn: yieldToken,\n                    tokenOut: underlyingToken,\n                    fee: poolFee,\n                    recipient: poolingManager,\n                    deadline: block.timestamp,\n                    amountIn: yieldBalance,\n                    amountOutMinimum: amountOutMinimum,\n                    sqrtPriceLimitX96: 0\n                });\n            uint256 output = uniswapRouter.exactInputSingle(params);\n            return (output);\n        } else {\n            ISwapRouter.ExactOutputSingleParams memory params = ISwapRouter\n                .ExactOutputSingleParams({\n                    tokenIn: yieldToken,\n                    tokenOut: underlyingToken,\n                    fee: poolFee,\n                    recipient: poolingManager,\n                    deadline: block.timestamp,\n                    amountOut: amount,\n                    amountInMaximum: amountInMaximum,\n                    sqrtPriceLimitX96: 0\n                });\n            uniswapRouter.exactOutputSingle(params);\n            return (amount);\n        }\n    }\n\n    function _applySlippageDepositExactInputSingle(\n        uint256 amount\n    ) internal view returns (uint256) {\n        return (minReceivedAmountFactor * amount) / (SLIPPAGE_PRECISION);\n    }\n\n    function _applySlippageWithdrawExactOutputSingle(\n        uint256 amount\n    ) internal view returns (uint256) {\n        return (SLIPPAGE_PRECISION * amount) / (minReceivedAmountFactor);\n    }\n\n    function _chainlinkLatestAnswer() internal view returns (int256) {\n        return chainlinkPricefeed.latestAnswer();\n    }\n\n    function _underlyingToYield(\n        uint256 amount\n    ) internal view override returns (uint256) {\n        return\n            _calculateUnderlyingToYieldAmount(\n                uint256(_chainlinkLatestAnswer()),\n                amount\n            );\n    }\n\n    function _yieldToUnderlying(\n        uint256 amount\n    ) internal view override returns (uint256) {\n        return\n            _calculateYieldToUnderlyingAmount(\n                uint256(_chainlinkLatestAnswer()),\n                amount\n            );\n    }\n\n    function _calculateUnderlyingToYieldAmount(\n        uint256 yieldPrice,\n        uint256 amount\n    ) internal view virtual returns (uint256) {\n        return (pricefeedPrecision * amount) / (yieldPrice);\n    }\n\n    function _calculateYieldToUnderlyingAmount(\n        uint256 yieldPrice,\n        uint256 amount\n    ) internal view virtual returns (uint256) {\n        return (amount * yieldPrice) / (pricefeedPrecision);\n    }\n}\n"
    },
    "contracts/strategies/uniswap/uniswapV3DiffDecimals.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.20;\n\nimport {ErrorLib} from \"../../lib/ErrorLib.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {UniswapV3Strategy} from \"./uniswapV3.sol\";\n\ncontract UniswapV3StrategyDiffDecimals is UniswapV3Strategy {\n    uint256 public underlyingTokenPrecision;\n    uint256 public yieldTokenPrecision;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() initializer {}\n\n    function initialize(\n        address _l2PoolingManager,\n        address _underlyingToken,\n        address _yieldToken,\n        address _uniswapRouter,\n        address _uniswapFactory,\n        address _chainlinkPricefeed,\n        uint256 _minReceivedAmountFactor,\n        uint24 _poolFee\n    ) public override initializer {\n        UniswapV3Strategy.initialize(\n            _l2PoolingManager,\n            _underlyingToken,\n            _yieldToken,\n            _uniswapRouter,\n            _uniswapFactory,\n            _chainlinkPricefeed,\n            _minReceivedAmountFactor,\n            _poolFee\n        );\n    }\n\n    function _checkDecimals(\n        address _underlyingToken,\n        address _yieldToken\n    ) internal override {\n        uint8 underlyingTokenDecimals = IERC20Metadata(_underlyingToken)\n            .decimals();\n        uint8 yieldTokenDecimals = IERC20Metadata(_yieldToken).decimals();\n        if (underlyingTokenDecimals == yieldTokenDecimals)\n            revert ErrorLib.InvalidDecimals();\n        underlyingTokenPrecision = 10 ** uint256(underlyingTokenDecimals);\n        yieldTokenPrecision = 10 ** uint256(yieldTokenDecimals);\n    }\n\n    function _calculateUnderlyingToYieldAmount(\n        uint256 yieldPrice,\n        uint256 amount\n    ) internal view override returns (uint256) {\n        return\n            (pricefeedPrecision * yieldTokenPrecision * amount) /\n            (yieldPrice * underlyingTokenPrecision);\n    }\n\n    function _calculateYieldToUnderlyingAmount(\n        uint256 yieldPrice,\n        uint256 amount\n    ) internal view override returns (uint256) {\n        return\n            (amount * yieldPrice * underlyingTokenPrecision) /\n            (pricefeedPrecision * yieldTokenPrecision);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "viaIR": false,
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "storageLayout",
          "devdoc",
          "userdoc",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}